======
 TODO
======


0.3 release
===========

``pre`` double linebreaks (complete)
------------------------------------

libxml2 quotes CR characters on output, this causes Firefox to insert extra
blank lines in ``<pre>`` blocks. As HTTP specified CRLF line endings for form
this is a problem for us. plone.org works around this with::

    <xsl:template match="pre/text()" xmlns:str="http://exslt.org/strings" mode="initial-stage">
        <xsl:value-of select="str:replace(., '&#13;', '')"/>
    </xsl:template>

This should be included in the boilerplate xsl.


Copy xsl directives from the rules file (complete)
--------------------------------------------------

We want to be able to do::

    <rules xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:strip-space elements="*" />
    </rules>

And have the directive copied into the output xsl.

In combination with the inline XSL, this should allow the ``extra.xsl``
support to be depracated



0.4 release
===========


Group directive
---------------

It would be useful to group together rules that share the same condition::

    <group css:if-content="body.section-documentation">
     <copy css:content="#foo" css:theme="#header" />
     <append css:content="#bar" css:theme="#footer />
    </group>

Nested conditions would be allowed and simply ANDed together.

* Maybe this should be called ``rules`` instead.


Path conditions
---------------

So far, XDV has taken the view that path configuration belongs in your
webserver .conf file (or collective.xdv control panel / paste ini file). But
it might be nice to centralise configuration in the rules.xml::

    <copy if-path-starts="/foo/bar/" ... />
    <copy if-path-ends="/index.html" ... />

To match multiple paths in a single rule separate them with spaces::

    <copy if-path-starts="/foo/   /bar/" ... />

This would be limited to simple string matching. Regexp would also be
possible, with the extension included in lxml or the libxslt-regexp-plugin_
for apache / nginx usage::

    <copy if-path-match=".*html" ... />

($path would be supplied to the template as a parameter)

.. _libxslt-regexp-plugin: http://fr.rpmfind.net/pub/libxml/plugins/


Refactor generated xslt
-----------------------

The xslt generated by the xdv compiler is currently uses three passes,
an initial-stage where drop rules are applied, an apply-theme stage
and a final-stage which ensures script and style element content is
unquoted. By collapsing this into a single stage we should see a
30-50% speedup (from my initial experiments).

The initial-stage and final-stage passes were also a plugin point to
include custom xslt, but xdv 0.3 now allows you to write inline xsl
should you wish::

    <xdv:replace css:theme="#details">
       <dl id="details">
           <xsl:for-each css:select="table#details > tr">
               <dt><xsl:copy-of select="td[1]/text()"/></dt>
               <dd><xsl:copy-of select="td[2]/node()"/></dd>
           </xsl:for-each>
       </dl>
    </xdv:replace>

extra.xsl is may also be used for output directives, such as
``<xsl:strip-space elements="*" />``. This would be put into the rules file
instead.

There is one slight complication. Take a content document as follows::

    <div class="bar">ONE</div>
    <div class="foo><div class="bar">TWO</div></div>

And rules::

    <drop css:theme=".foo"/>
    <copy css:content=".bar" theme="#info"/>

Should this give the output (as currently)::

    <div id="info"/>
    <div class="bar">ONE</div>
    </div>

or (the easier to implement in a single pass template)::

    <div id="info"/>
    <div class="bar">ONE</div>
    <div class="bar">TWO</div>
    </div>

I guess the former might be implemented by prefixing
ancestor-or-self::, though that may interact badly with complex xpath
selectors.


Include directive (rejected)
----------------------------

The current xinclude syntax is complex, maybe we need a dedicated directive::

    <include href="rules2.xml"/>

* Lars noted that by placing an id on groups, it would be possible to pull in
  groups with xinclude. e.g.:

  In rules.xml::

    <rules>
      <xi:include href="common.xml#ruleset1">
    <rules>

  In common.xml::

    <rules>
      <group id="ruleset1">
        <copy css:theme="#content" css:content="#content" />
      </group>
      <group id="ruleset2">
        <copy css:theme="#footer" css:content="#footer" />
      </group>
    </rules>

  With the result::

    <rules>
      <group id="ruleset1">
        <copy css:theme="#content" css:content="#content" />
      </group>
    </rules>

* Nested <rules> now works, so this is not necessary.

Theme directive / multiple theme support
----------------------------------------

It would be nice to specify the theme in the rules file itself::

    <theme href="theme.html"/>

Multiple themes may be used with conditions::

    <theme css:if-content="body.section-foo" href="foo.html"/>
    <theme href="theme.html"/>

When no conditional theme matches and there is no unconditional theme, the
page would still be parsed and serialized through libxml2.


Omit directive
--------------

Similar to TAL's omit-tag, it leaves the contents of the matched node
in place, while omitting the start and end tags (along with any
attributes)::

    <omit css:theme="#foo"/>

* Martin points out that ``omit`` is a synonym for ``drop``, though we already
  have ``copy`` and ``replace``.


Better debugging support
------------------------

There needs to be some mechanism to feedback to the integrator which rules are
being matched, probably by writing out information into comments.



Maybe sometime in the future
============================


pyref support
-------------

It might be useful to add pyref_ support for collective.xdv and dv.xdvserver.

.. _pyref


i18n support
------------

It would be nice to be able to leverage the existing gettext translation
machinery for message strings within the template. I don't know exactly what
syntax we should use, but it would be quite easy to implement with lxml (see
this perl example_.) For Apache / Nginx use we would need a C libxslt plugin,
but that shouldn't be too hard.

Maybe something like::

    <translate css:theme="#footer-text" id="copyright-message"/>

.. _example: <http://xims.info/presentations/200801107_tcpw2008-I18N_with_XSLT_and_what_Perl_has_got_to_do_with_it/>`_
